// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: like.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countLikesByPost = `-- name: CountLikesByPost :one
SELECT count(*) 
FROM likes
WHERE post_id = $1
`

func (q *Queries) CountLikesByPost(ctx context.Context, postID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countLikesByPost, postID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteLike = `-- name: DeleteLike :exec
DELETE FROM likes
WHERE user_id = $1 AND post_id = $2
`

type DeleteLikeParams struct {
	UserID uuid.UUID `json:"user_id"`
	PostID uuid.UUID `json:"post_id"`
}

func (q *Queries) DeleteLike(ctx context.Context, arg DeleteLikeParams) error {
	_, err := q.db.Exec(ctx, deleteLike, arg.UserID, arg.PostID)
	return err
}

const findAllLikes = `-- name: FindAllLikes :many
SELECT user_id, post_id, created_at FROM likes
`

func (q *Queries) FindAllLikes(ctx context.Context) ([]Like, error) {
	rows, err := q.db.Query(ctx, findAllLikes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Like
	for rows.Next() {
		var i Like
		if err := rows.Scan(&i.UserID, &i.PostID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLikesByPost = `-- name: FindLikesByPost :many
SELECT 
  l.user_id,
  l.post_id,
  l.created_at,
  u.id         AS user_id,
  u.name       AS user_name,
  u.email      AS user_email,
  u.created_at AS user_created_at,
  u.updated_at AS user_updated_at
FROM likes l
JOIN users u ON u.id = l.user_id
WHERE l.post_id = $1
`

type FindLikesByPostRow struct {
	UserID        uuid.UUID   `json:"user_id"`
	PostID        uuid.UUID   `json:"post_id"`
	CreatedAt     time.Time   `json:"created_at"`
	UserID_2      uuid.UUID   `json:"user_id_2"`
	UserName      string      `json:"user_name"`
	UserEmail     pgtype.Text `json:"user_email"`
	UserCreatedAt time.Time   `json:"user_created_at"`
	UserUpdatedAt time.Time   `json:"user_updated_at"`
}

func (q *Queries) FindLikesByPost(ctx context.Context, postID uuid.UUID) ([]FindLikesByPostRow, error) {
	rows, err := q.db.Query(ctx, findLikesByPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindLikesByPostRow
	for rows.Next() {
		var i FindLikesByPostRow
		if err := rows.Scan(
			&i.UserID,
			&i.PostID,
			&i.CreatedAt,
			&i.UserID_2,
			&i.UserName,
			&i.UserEmail,
			&i.UserCreatedAt,
			&i.UserUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertLike = `-- name: InsertLike :one
INSERT INTO likes (user_id, post_id)
VALUES ($1, $2)
RETURNING user_id, post_id, created_at
`

type InsertLikeParams struct {
	UserID uuid.UUID `json:"user_id"`
	PostID uuid.UUID `json:"post_id"`
}

func (q *Queries) InsertLike(ctx context.Context, arg InsertLikeParams) (Like, error) {
	row := q.db.QueryRow(ctx, insertLike, arg.UserID, arg.PostID)
	var i Like
	err := row.Scan(&i.UserID, &i.PostID, &i.CreatedAt)
	return i, err
}
